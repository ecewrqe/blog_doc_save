## 二进制
二进制是由0和1组成，二进制有位数，每逢2进一位。

| 二进制        | 十进制         |
| ------------- |:-------------:|
| 0         | 0         |
| 1         | 1         |
| 2         | 10         |
| 3         | 11         |

| 位数   |8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| ----- |:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| 最小数 | 256 |128 | 64 | 32 | 16 | 8 | 4 | 2 | 1|
                      1    1    0   0   0    1   1
100
当前位数的最小数是前面所有开始数相加之和+1


64+32+16+8  4  2  1 = 120


8bits=1Byte

## 位运算

```
a=97        #二进制01100001
b=248        #二进制11111000    

```

| a     | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |
| ----- | - | - | - | - | - | - | - | - |
| b     | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| a&b   | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| a\|b  | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |
| a^b   | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 |

位运算是基于二进制的运算，运算速度会更快，一般不常用
- 位与 &  :两数每一位对应比较，只有都为正才为正
- 位或 |  :两数每一位对应比较，只要为正都为正
- 位与或^ :两数每一位对应比较，两数不一样为正

### 左移右移
```
a=97=0b01100001

a >> 1  #表示该数二进制位往右移1位--->0b00110000---->48
97/2==48

a >> 2  #表示该数二进制位往右移2位--->0b00011000---->24
97/2^2==48

a >> 3  #表示该数二进制位往右移3位--->0b00001100--->12
97/2^3=12

a >> n  #表示该数二进制位往右移n位---->表示a除以2的n次方---> a/2^n
a << n  #表示该数二进制位往左移n位---->表示a乘以2的n次方---> a*2^n
```
往左移位，每移动一位，最左边的丢弃位，右边增加几位0
往右移位，每移动一位，最右边的丢弃位,左边看是否为负数，正数补0，负数补1

### 取反，这里的取反仅仅是取反，不是反码

```
a=12=[1100]=[01100]
~a=-13=[-1101]=[11101]
```
负数的取反是符号位取反-1
正数的取反是符号位取反+1

## 编码
#### ascii
256个数刚好可以包含所有控制字符，符号，数字，字母。就是ascii码

每个数字和ascii字符一一对应
<img src="http://120.77.40.63/wp-content/uploads/2017/02/ascii.gif" alt="" class="alignnone size-medium wp-image-98" />
97代表a，二进制就是111000
将ass we can解析成机器所能读懂的语言


|字符串  |a|s|s|space|w|e|space|c|a|n|
|ascii码 |97|115|115|32|119|101|32|99|97|110|    
|二进制码 |1100001|1110011|1110011|100000|1110111|1100101|100000|1100011|1100001|1101111|


计算机只按8位分割，每一个字符都是8位，不够的位置用0代替

结果是：01100001 01110011 01110011 00100000 01110111 01100101 00100000 01100011 01100001 00101111

十六进制表示：0x61 0x73 0x73 0x20 0x77 0x65 0x20 0x63 0x61 0x2F

十六进制是每4位二进制表示一个十六进制，把一段二进制分成4位一组，如果不满四位的在前面加上0，组成4位


常见的几种ascii
32为空格
48-57为数字
65-90为大写字母
97-122为小写字母
以上：ascii码只能代表以上几种字符，只适用于使用英语的国家,如果要表示类似汉字，希腊文字等，只能在ascii码的基础上再扩展8位，变成65535-255个位置供全球所有的汉字，平假名/片假名或其他等。
#### unicode
就发展成unicode---万国码，每个字由16位组成，原来的ascii码也要多加八个0，是2个ascii码表示，4个十六进制数表示(4个二进制表示一个十六进制)，由于计算机的底层都是由ascii码组成，8位就足够，现在要改成unicode，每一个字母要占内存2倍。所以非常耗资源。ascii:\u00ff，latin:\u0fff, 汉字:\uffff
```
<python2>
>>> print(u"\u0032")
2
>>> print(u"\u0056")
V
```
####utf8
utf8就是用来解决这个问题的，它会智能的判断ascii占一位，西方字母占2位，汉字占3位。
ascii:\xff，latin:\xfff

#### GBK
然后是GBK编码：BGK全称《汉字内码扩展规范》，现在的windows系统都支持GBK编码，GBK，GB2312收编的汉字占2个字节，总计23940个码位，共收入21886个汉字和图形符号。

#### utf-8
可变长的万国码，会自动判断是否是
####编码遗留问题
python3.X默认编码为utf-8，python2.x没有这样的指定，所以输入中文会出错，需要指定像这种，
```
#-*-coding:utf-8-*-
```
windows中文版本的系统都支持GBK编码，默认为GBK。linux默认支持utf-8，所以从windows传给linux文件时会有字符集的问题，所以要使用dos2unix。。

### 再来谈谈python中的bytes和str
任何看到的字符以及文字都是表象，计算机内部都是以编码形式存在。同一个字不同的编码格式在计算机内部存储的是不一样的。utf8的"你好"和gbk的"你好"和unicode的"你好"是不一样的，但是内部都是一串ascii，是一串什么样的ascii呢：\xe4\xbd\xa0\xe5\xa5\xbd(utf8格式)，\xc4\xe3\xba\xc3(gbk格式)，\u4f60\u597d(unicode格式)
如：输出时，遇到一个有能力解析utf8格式字符串的平台，就能显示utf8格式的"你好"


#### python3
判断字符串的编码方式：
1，判断当前的文本编辑器是什么编码格式，或者当前终端是什么编码格式，文字就是什么格式的：比如看到浏览器的这些文字，浏览器设置的编码格式是什么，就是什么格式。
2，如果是要编译的，看编译器默认把代码传成什么格式，如python2默认是ascii的，在utf的文本编辑器写的文字，用python2编译后是"\x11\x22\xbb"，

在windows终端输入"你好"，看到的是"你好"，但是内存中是"\xc4\xe3\xba\xc3"，python3默认支持的文本编辑器的编码是utf8，默认支持的终端编码是终端的默认编码，能把这两个字解码成unicode，运行程序时内存中的"你好"就是"\u4f60\u597d"。因为unicode能直接编码成任何其他编码格式(utf8,gbk...)，所以直接"你好".encode("utf8")就能转成utf8。
为什么能在终端直接显示"\u4f60\u597d",因为终端支持unicode格式的

#### python2
python2内部，字符串以ascii形式传输，在linux终端输入""


bytes是将字符变成字符编码，可以直接在字符串后面跟encode()表示编码---就是把很形象的字符，改成计算机能看懂的编码
```
"你好".encode("utf8")   #因为utf8中一个汉字占三个字节
得出：b'\xe4\xbd\xa0\xe5\xa5\xbd'   
```

b'\xe4\xbd\xa0\xe5\xa5\xbd' 

\xe4\xbd\xa0   表示"你"   二进制：1110 0100|1011 1101|1010 0000
\xe5\xa5\xbd   表示"好"   二进制：1110 0101|1010 0101|1011 1101

所以像socket传输信息，首先要转成计算机能看懂的字节码，以上的字节码是utf8的字节码，只能用utf8来解码

下面来看一下它的gbk编码：

```
"你好".encode("gbk")     #gbk是两个字节/每个汉字
得出：b'\xc4\xe3\xba\xc3'
```

二进制表示：1100 0100|1110 0011|1011 1010|1100 0011

