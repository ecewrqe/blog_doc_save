<img src="http://www.doublenactive.cn/wp-content/uploads/2017/02/425762-20151107170723664-951337746.png" alt=""  class="alignnone size-medium wp-image-142" />

##### all()和any()
all:如果所有为正，则为正，可迭代对象，如果是空也为正
any:如果有一个为正，则为正，可迭代对象，如果为空则为假

##### 进制转换:bin,oct,hex
bin(number->int)->str
hex(number->int)->str
``` python
a=0x10
print(bin(a))
print(hex(a))
print(oct(a))
```
##### chr(num->ascii)和ord(ascii->num)
``` python
print(chr(97))
print(ord("a"))
```
##### bytearray操作原内存地址

##### map,filter,reduce
map(func,iterable)->mapIterator
iter中的每个值放入func中返回值给map迭代器
filter返回结果为正的值
reduce：func必须传两个参数
``` python
m_iter=map(lambda x:x+1,[1,2,3,4,5])
print(m_iter.__next__())
print(m_iter.__next__())
print(m_iter.__next__())
print(m_iter.__next__())

f_iter=filter(lambda x:x if x<3 else x+1 ,[1,2,3,4,5])
print(f_iter.__next__())
print(f_iter.__next__())
print(f_iter.__next__())

from functools import reduce

ret=reduce(lambda x,y:x*y,[1,2,3,4,5])
print(ret)             #结果为120
```



##### eval,exec,complie
eval:接收表达式，返回结果
exec接收python语句，执行

``` python
print(eval("2*3+5",a))
exec("print('hello')")
compile("print('hello')","","exec")
```

##### locals,globals,vars,dir
globals列出所有全局变量
locals列出所有局部变量
vars

##### frozenset不可变集合

##### zip(a,b,c)合并多个列表
``` python
a=[1,2,3]
b=[4,5,6]
c=[7,8,9]
print(list(zip(a,b,c)))
for i in zip(a,b,c):
    print(i)

得出
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
(1, 4, 7)
(2, 5, 8)
(3, 6, 9)
```


### 迭代器iterator和生成器generator
在python2中没有生成器和迭代器这样的说法，range在p2中是生成列表
##### 生成器
range是一个生成器
``` python
r_ret = range(10)
print(r_ret)
for i in r_ret:
    print(i)

```

``` python
lior=[i for i in r_ret]      #列表
itor=(i for i in r_ret)      #生成器
print(itor)
print(itor.__next__())        #可被next叫迭代器
print(itor.__next__())
print(itor.__next__())
```
##### 迭代器和可迭代对象
可迭代对象是可遍历，可以被for循环的变量，列表，字符串，字典。。
迭代器属于可遍历对象，是从头到尾只遍历一遍，可以用next和\__next\__
列表字典这种，是数据事先在内存已存在，所以可以查找，修改，删除任意值。所以一开始就占一大块内存
迭代器一开始结果并不在内存中，用next和for一边遍历一边生成，所以占内存只是遍历到那个地方，才产生，节省空间

##### yeild语句
``` python
def f1():
    print("aaaaa")
    yield
    print("bbbbb")

print(f1())
f1_tmp=f1()
next(f1_tmp)
next(f1_tmp)
####
def f2(n):
    print("aaaaa")
    n=n+1
    yield n
    print("bbbbb")
    n = n + 1
    yield n
    print("ccccc")

f2_tmp=f2(10)
print(next(f2_tmp))
print(next(f2_tmp))

得出：
aaaaa
11
bbbbb
12

####
def f3():
    while True:
        tmp=yield
        print(tmp)
f3_tmp=f3()
f3_tmp.__next__()
f3_tmp.send("hello")
f3_tmp.send("alex")
f3_tmp.send("batman")
```

### 文件操作
##### 写一个word的过程:
打开word文件->写文件->关闭word文件
打开word文件的时候，内容一下子全部读到内存中，然后才能修改。如果像linux中的cat这些读文件的工具，打开了之后只是一边读，一边写入内存，一边打印，打印完后释放内存,所以大文件不会卡
可以这么理解：一个文件相当于塑料袋，里面装着水(内容)，当文件打开时，相当于给塑料袋开了一道口子并通了一根管子，如果不管它，它会全部流出，等用完后再把它通过管子回到塑料袋。

### open
打开文件：open(name->str,mode->str,buffer->int(-1),encoding->str(None),
error->str(None),newline->any(None),closefd->any(None),opener->any(None))->fileObj
```
mode:
    'r'       open for reading (default)
    'w'       open for writing, truncating the file first
    'x'       create a new file and open it for writing
    'a'       open for writing, appending to the end of the file if it exists
    'b'       binary mode
    't'       text mode (default)
    '+'       open a disk file for updating (reading and writing)
    'U'       universal newline mode (deprecated)
```


我现在有这样一个文件
```  ponys_file
tw:twilight
rd:rainbow dash
pp:pinkie pie
```


```
#读
f=open("ponys_file")
f.close()
#写
f=open("ponys_file","w")
f.close()
#追加
f=open("ponys_file","a")
f.close()
```

##### with...as...：自动关闭
```
with open("ponys_file") as f:
    xxxxxx
```

### fileObj
close(self->fileObj)->None
fileno(self0>fileObj)->int   文件描述符
```
f1=open("ponys_file","r")
f2=open("ponys_write","w")
print(f1.fileno())
print(f2.fileno())

f1.close()
f2.close()
#得出 3 4
```
##### 读
read(self->fileObj,n->int)->str    *n为指定取多少，和下面的limit，hint一样*
readable(self->fileObj)->bool
```
print(f1.read())
# tw:twilight
# rd:rainbow dash
# pp:pinkie pie
print(f1.read(10))
# tw:twiligh    
```
readline(self->fileObj,limit->int(-1))->str

```
print(f1.readline())
# tw:twilight
```
readlines(self->fileObj,hint->int(-1))->list
```
print(f1.readlines())
['tw:twilight\n', 'rd:rainbow dash\n', 'pp:pinkie pie\n']
```

##### 写
write(self->fileObj,s->str/bytes)->int
```
f1=open("ponys_file","w")
print(
    f1.write('''\
aj:apple jack
fs:fluttershy
'''
    )    #写入的字数
)

f1.close()
```

```   ponys_file
aj:apple jack
fs:fluttershy
```
writelines(self->fileObj,\*args,**kwargs)->int    传入列表
```
f1.writelines([
    "aj:apple jack\n",
    "fs:fluttershy\n",
])

```
writeable(self->fileObj)->bool

flush(self->fileObj)->None    F5
tell(self->fileObj)->int     返回当前指针位置,a模式的指针位置为最后
seek(self->fileObj,offset->int,whence->int(io.SEEKSET))->None    设置指针位置
```
print(f1.tell())  #30
f1.seek(10)
print(f1.tell())  #10

```

self.closed->bool
self.encoding->str