## 二进制
二进制是由0和1组成，二进制有位数，每逢2进一位。

| 二进制        | 十进制         |
| ------------- |:-------------:|
| 0         | 0         |
| 1         | 1         |
| 2         | 10         |
| 3         | 11         |

| 位数   |8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| ----- |:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| 最小数 | 256 |128 | 64 | 32 | 16 | 8 | 4 | 2 | 1|
                      1    1    0   0   0    1   1
100
当前位数的最小数是前面所有开始数相加之和+1


64+32+16+8  4  2  1 = 120


8bits=1Byte

## 位运算

```
a=97        #二进制01100001
b=248        #二进制11111000    

```

| a     | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |
| ----- | - | - | - | - | - | - | - | - |
| b     | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| a&b   | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| a\|b  | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |
| a^b   | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 |

位运算是基于二进制的运算，运算速度会更快，一般不常用
- 位与 &  :两数每一位对应比较，只有都为正才为正
- 位或 |  :两数每一位对应比较，只要为正都为正
- 位与或^ :两数每一位对应比较，两数不一样为正

### 左移右移
```
a=97=0b01100001

a >> 1  #表示该数二进制位往右移1位--->0b00110000---->48
97/2==48

a >> 2  #表示该数二进制位往右移2位--->0b00011000---->24
97/2^2==48

a >> 3  #表示该数二进制位往右移3位--->0b00001100--->12
97/2^3=12

a >> n  #表示该数二进制位往右移n位---->表示a除以2的n次方---> a/2^n
a << n  #表示该数二进制位往左移n位---->表示a乘以2的n次方---> a*2^n
```
往左移位，每移动一位，最左边的丢弃位，右边增加几位0
往右移位，每移动一位，最右边的丢弃位,左边看是否为负数，正数补0，负数补1

### 取反，这里的取反仅仅是取反，不是反码

```
a=12=[1100]=[01100]
~a=-13=[-1101]=[11101]
```
负数的取反是符号位取反-1
正数的取反是符号位取反+1

## 编码
#### ascii
256个数刚好可以包含所有控制字符，符号，数字，字母。就是ascii码

每个数字和ascii字符一一对应
<img src="http://120.77.40.63/wp-content/uploads/2017/02/ascii.gif" alt="" class="alignnone size-medium wp-image-98" />
97代表a，二进制就是111000
将ass we can解析成机器所能读懂的语言


|字符串  |a|s|s|space|w|e|space|c|a|n|
|ascii码 |97|115|115|32|119|101|32|99|97|110|    
|二进制码 |1100001|1110011|1110011|100000|1110111|1100101|100000|1100011|1100001|1101111|


计算机只按8位分割，每一个字符都是8位，不够的位置用0代替

结果是：01100001 01110011 01110011 00100000 01110111 01100101 00100000 01100011 01100001 00101111

十六进制表示：0x61 0x73 0x73 0x20 0x77 0x65 0x20 0x63 0x61 0x2F

十六进制是每4位二进制表示一个十六进制，把一段二进制分成4位一组，如果不满四位的在前面加上0，组成4位


常见的几种ascii
32为空格
48-57为数字
65-90为大写字母
97-122为小写字母
以上：ascii码只能代表以上几种字符，只适用于使用英语的国家,如果要表示类似汉字，希腊文字等，只能在ascii码的基础上再扩展8位，变成65535-255个位置供全球所有的汉字，平假名/片假名或其他等。
#### unicode
就发展成unicode---万国码，每个字由16位组成，原来的ascii码也要多加八个0，是2个ascii码表示，4个十六进制数表示(4个二进制表示一个十六进制)，由于计算机的底层都是由ascii码组成，8位就足够，现在要改成unicode，每一个字母要占内存2倍。所以非常耗资源。
####utf8
utf8就是用来解决这个问题的，它会智能的判断ascii占一位，西方字母占2位，汉字占3位。

#### GBK
然后是GBK编码：BGK全称《汉字内码扩展规范》，现在的windows系统都支持GBK编码，GBK，GB2312收编的汉字占2个字节，总计23940个码位，共收入21886个汉字和图形符号。

#### utf-8
可变长的万国码，会自动判断是否是
####编码遗留问题
python3.X默认编码为utf-8，python2.x没有这样的指定，所以输入中文会出错，需要指定像这种，
```
#-*-coding:utf-8-*-
```
windows中文版本的系统都支持GBK编码，默认为GBK。linux默认支持utf-8，所以从windows传给linux文件时会有字符集的问题，所以要使用dos2unix。。

###再来谈谈python中的bytes和str
bytes是将字符变成字符编码，可以直接在字符串后面跟encode()表示编码---就是把很形象的字符，改成计算机能看懂的编码
```
"你好".encode("utf8")   #因为utf8中一个汉字占三个字节
得出：b'\xe4\xbd\xa0\xe5\xa5\xbd'   
```

b'\xe4\xbd\xa0\xe5\xa5\xbd' 

\xe4\xbd\xa0   表示"你"   二进制：1110 0100|1011 1101|1010 0000
\xe5\xa5\xbd   表示"好"   二进制：1110 0101|1010 0101|1011 1101

所以像socket传输信息，首先要转成计算机能看懂的字节码，以上的字节码是utf8的字节码，只能用utf8来解码

下面来看一下它的gbk编码：

```
"你好".encode("gbk")     #gbk是两个字节/每个汉字
得出：b'\xc4\xe3\xba\xc3'
```

二进制表示：1100 0100|1110 0011|1011 1010|1100 0011

