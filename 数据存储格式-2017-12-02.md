### json和pickle
这两个都是用来存储数据得，json存储的形式是字符串，任何语言通用，但是只能存储基本格式(包括列表，字典)。
pickle存储的是二进制，只能在python之间流通，但是可以存储除了基本数据之外，函数，类，对象
##### json书写语法
```
{
  "yuzusoft":
  {
    "birthYear": "2006",
    "cross":[
      "こぶいち",
      "むりりん"
    ],
    "country":"japan",
    "job":"galgame",
    "works":[
      "天神乱漫",
      "dracu-riot!"
    ]
  },
  "favorite":{
    "birthYear":"2004",
    "cross":["司田カズヒ","GT","なつめえり"],
    "country":"japan",
    "job":"galgame",
    "works":[
      "星空のメモリア",
      "いろとりどりのセカイ",
      "いろとりどりのヒカリ"
    ]
  }
}
```

##### 方法:
主要关注三个东西：某个任意对象，字符串(二进制)，文件对象
dumps指某个对象变成了字符串dumps(obj->any)->str
dump指某个对象变成了字符串，并放入了该文件对象指向的文件里 dump(obj,f->fileObj)->None
loads指字符串变成了对象loads(str)->obj
load指文件对象中的字符串变成了对象load(fileObj)->obj
dump中公用的参数：
ensure_ascii=True    #默认把对象变成unicode形式的编码后的字符串
sort_keys           排序键

##### json格式转换
对象无法直接转换成json字符串，如果想要把某类对象格式化成字符串就用下面的方法
```
dic = {"time":datetime.datetime.now()}

class DateJsonEncode(json.JSONEncoder):
    def default(self,obj):
        if isinstance(obj,datetime.datetime):
            time_str=obj.strftime(DATETIME_FORMATTER)
            return time_str
        return json.JSONEncoder.default(self,obj)
```

### xml
##### xml语法
xml开头要有<?xml version="1.0" encoding="UTF-8" ?>
xml从一个根节点开始，就像linux的目录结构一样
xml的成分:节点(node)、标签(tag)、属性(attrib)和文本(text)
和html语法类似
``` xml
<?xml version="1.0" encoding="UTF-8" ?>
<galgame_company>
      <yuzusoft>
        <birthYear>2006</birthYear>
        <cross_group>
            <cross1>こぶいち</cross1>
            <cross2>むりりん</cross2>
        </cross_group>
        <country>japan</country>
        <job>galgame</job>
        <works_group>
            <works1>天神乱漫</works1>
            <works1>dracu-riot!</works1>
        </works_group>
    </yuzusoft>
    <favorite>
        <birthYear>2004</birthYear>
        <cross_group>
            <cross1>司田カズヒ</cross1>
            <cross2>GT</cross2>
            <cross3>なつめえり</cross3>
        </cross_group>
        <country>japan</country>
        <job>galgame</job>
        <works_group>
            <works>星空のメモリア</works>
            <works>いろとりどりのセカイ</works>
            <works>いろとりどりのヒカリ</works>
        </works_group>
    </favorite>
</galgame_company>
```
##### python对xml的解析
xml从解析到拿到数据：
先解析得到树->拿到树根节点->可遍历
``` python
import xml.etree.ElementTree as ET
xmlTree=ET.parse("Read.xml")     #先解析文件
root=xmlTree.getroot()        #拿到根节点
```
直接读取字符串
```
root = ET.fromString("<?xml version="1.0" encoding="UTF-8"?><note><to>World</to><from>Linvo</from><heading>Hi</heading><body>Hello World!</body></note>")

print(root.tag)  #note
```


getroot(self->ElementTree)->Element    #拿到元素节点
iter(self->Element,tag)->Element          # 在子节点中找到某一个标签名，返回该标签的元素节点
findall(self->Element,tag)->Element     #只找下一层
find(self->Element,tag)        #下一层第一次照出来的
遍历节点:
``` python
#遍历所有
for company in root:
    print("-->",company.tag,company.attrib)
    for item in company:
        print("\t-->",item.tag,item.text)
#仅遍历cross1节点
for company in root.iter("cross1"):
    print("-->",company.tag,company.attrib)
    for item in company:
        print("\t-->",item.tag,item.text)
```

修改元素：
直接在拿到的节点上修改tag、attrib、text
remove(subelement-Element)->None
set(key,value)        # 修改属性

写入:
write(self->ElementTree,filename,encoding,
xml_declaration      # 是否保存头部信息
)

创建文档：
Element(self->ElementTree,root_tag)->root_Element
SubElement(self->ElementTree,parent_tag)->sub_Element
ElementTree(self->ElementTree,root_Element)->ElementTree

```
root=ET.Element("galgame_company",attrib={"ddd":"fff"})
print(root)
ET.SubElement(root,"Yuzusoft",attrib={"kkk":"jjj"})
xmlTree=ET.ElementTree(root)
print(xmlTree)
xmlTree.write("text2.xml")
```
### shelve
封装了pickle
写
```
import shelve
class A:
    pass
def func():
    pass
game="senlen"

sl=shelve.open('shelvve_Test')
sl["game"]=game
sl["A"]=A
sl.close()
```
读
```
sl=shelve.open("shelvve_Test")
print(list(sl.keys()))
```

当值是类或函数时，读的时候必须本地声明，读出来的结果是本地的那个
### configparser
Conf文件大致样子
```
[Unit]
Description=The Salt API
After=network.target

[Service]
Type=notify
LimitNOFILE=8192
ExecStart=/usr/bin/salt-api
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
```

Conf文件一般在linux里面的扩展名是conf，在windows中是ini
注释：
;或者#开头

```
#创建一个conf
import configparser
config=configparser.ConfigParser()
allow_no_value=True

config['Unit']={
    "Description" : "The Salt API",
    "After" : "network target",
}
#写入文件
with open("ddd/salt-api.ini","w") as configfile:
    config.write(configfile)
		
#读取
config.read("ddd/salt-api.ini")
```

Config有一个特殊的模块是DEFAULT
表示在所有以下的模块中都有DEFAULT模块的内容
此模块的key值不能与下面所有的模块的key值冲突
config.sections()   # 打印所有除了DEFAULT以外的模块名

解析conf
read_string(str)---读取字符串
read_dict(dict)
read(file,encoding...)    ---读取文件

##### 操作模块和键值
remove_option(section,option)删除一项配置
remove_section(section)删除一项模块
add_section(section)添加模块
sections()列出所有模块
options(section)列出模块下的所有配置

has_section(section)是否有该模块
has_option(section,option)是否有该配置
