来说说python传参
```python
num1=10
num2=num1
print(num1,num2)
num2=20
print(num1,num2)
```
得到的是num1=10,num2=20

赋值前
```
graph LR
num1-->10
num2-->10
```
赋值后
```
graph LR
num1-->10
num2-->20
```

可以理解为num1和num2都引用了某一个储存10的内存
当num2赋了另一个值，首先另一个值开辟了一块空间，指向的10的链断开，指向了另一个内存

在C语言中是这么理解的：
```C
int num1=10;    //num1和10的地址是绑定的
int* pnum1=&num1;   //pnum1指向了num1的地址
num1=20    该地址下的值更改为20
pnum1指向的地址还是没有变,*pnum1==20
int num2=20;     //num2又开辟了一块内存空间
pnum1=&num2;     //pnum1指向了num2的地址
```
所以这里的pnum1的作用和python的num2的作用一样都是引用


```python
def f1(a,b=[]):
    b.append(a)
f1(1)
fl(2,[])
f1(3)
```

python解释器解释过程：
python解释器是二进制文件，它先要把py文件读出来，读一行执行一行，
在读def f1(a,b=[]):的时候已经把f1存入内存，a和b已经指向了对应的内存地址
当执行到f1(a=1)的时候，是，a改变了引用，指向了1这个地址，b还是原来那个b
b.append(a)所以就是[1]
当函数f1(1)结束执行的时候1的作用已就结束了，a还是指向原来那个,因为原来那个a是是大的作用域
当执行f1(a=2)的时候，a又改变了地址，指向了2，b也改变了地址指向了新的[],所以结果是[2]，这一次再次结束的时候，2和[]都被销毁
a和b仍旧指向原来那个
所以当执行f3()的时候b=[1,3]

##### 拷贝


photoshop有这样几个功能：
能用钢笔，铅笔，橡皮,


假设，为了便于增加功能，这些工具都统一放到工具箱内，而这个工具箱能被任何一个软件公用，于是就有了：
```
软件A:
    name:photoshop
    tools:钢笔
          铅笔
          橡皮
```
adobe公司又开发了一个软件叫illustrator，由于它们两个的功能相似，所以工具箱也是引用tool里的
```
软件B:
    name:illustrator
    tools:钢笔
          铅笔
          橡皮
```
这两个软件只是名字改了一下，工具箱还是同一个
然后我要再工具箱中创建一个选取工具,只要创建一次软件A和软件B都用了
在python中表示就是

```python
softA={
    name:photoshop,
    tools:[
        "钢笔",
        "铅笔",
        "橡皮",
    ]
}

softB=softA.copy()
softB["name"]="illustrator"
#now
softB["tools"].append("选取")
#所以softA也能看到选取
```
称这样的拷贝为浅拷贝，只拷贝第一次，这样占用内存空间少，共享了某一段内存
以下为深拷贝
```
import copy
softC=copy.deepcopy()
#表示从头到尾拷贝一份
softC["tools"][0]="彩色钢笔"  #A和B不受影响
```

